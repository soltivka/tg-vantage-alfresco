{"version":3,"file":"resultSetContext.js","sourceRoot":"","sources":["resultSetContext.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;EAeE;;;AAEF,iEAA8D;AAC9D,+DAA4D;AAC5D,mDAAgD;AAChD,iFAA8E;AAC9E,6EAA0E;AAC1E,mDAAgD;AAKhD,MAAa,gBAAgB;IAyBzB,YAAY,KAAW;QAEnB,IAAI,KAAK,EAAE;YACP,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC3B,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,yCAAmB,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YAC9F,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,6BAAa,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YAC5E,IAAI,KAAK,CAAC,YAAY,EAAE;gBACpB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,IAAS,EAAE,EAAE;oBACrD,OAAO,IAAI,2DAA4B,CAAC,IAAI,CAAC,CAAC;gBAClD,CAAC,CAAC,CAAC;aACN;YACD,IAAI,KAAK,CAAC,YAAY,EAAE;gBACpB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,IAAS,EAAE,EAAE;oBACrD,OAAO,IAAI,6BAAa,CAAC,IAAI,CAAC,CAAC;gBACnC,CAAC,CAAC,CAAC;aACN;YACD,IAAI,KAAK,CAAC,MAAM,EAAE;gBACd,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAS,EAAE,EAAE;oBACzC,OAAO,IAAI,2CAAoB,CAAC,IAAI,CAAC,CAAC;gBAC1C,CAAC,CAAC,CAAC;aACN;YACD,IAAI,KAAK,CAAC,UAAU,EAAE;gBAClB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAS,EAAE,EAAE;oBACjD,OAAO,IAAI,uDAA0B,CAAC,IAAI,CAAC,CAAC;gBAChD,CAAC,CAAC,CAAC;aACN;SACJ;IACL,CAAC;CAEJ;AAtDD,4CAsDC","sourcesContent":["/*!\n* @license\n* Copyright 2018 Alfresco Software, Ltd.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { GenericFacetResponse } from './genericFacetResponse';\nimport { ResponseConsistency } from './responseConsistency';\nimport { ResultBuckets } from './resultBuckets';\nimport { ResultSetContextFacetQueries } from './resultSetContextFacetQueries';\nimport { ResultSetContextSpellcheck } from './resultSetContextSpellcheck';\nimport { SearchRequest } from './searchRequest';\n\n/**\n * Context that applies to the whole result set\n */\nexport class ResultSetContext {\n    consistency?: ResponseConsistency;\n    request?: SearchRequest;\n    /**\n     * The counts from facet queries\n     */\n    facetQueries?: ResultSetContextFacetQueries[];\n    /**\n     * The counts from field facets\n     */\n    facetsFields?: ResultBuckets[];\n    /**\n     * The faceted response\n     */\n    facets?: GenericFacetResponse[];\n    /**\n     * Suggested corrections\n\nIf zero results were found for the original query then a single entry of type \\\"searchInsteadFor\\\" will be returned.\nIf alternatives were found that return more results than the original query they are returned as \\\"didYouMean\\\" options.\nThe highest quality suggestion is first.\n\n     */\n    spellcheck?: ResultSetContextSpellcheck[];\n\n    constructor(input?: any) {\n\n        if (input) {\n            Object.assign(this, input);\n            this.consistency = input.consistency ? new ResponseConsistency(input.consistency) : undefined;\n            this.request = input.request ? new SearchRequest(input.request) : undefined;\n            if (input.facetQueries) {\n                this.facetQueries = input.facetQueries.map((item: any) => {\n                    return new ResultSetContextFacetQueries(item);\n                });\n            }\n            if (input.facetsFields) {\n                this.facetsFields = input.facetsFields.map((item: any) => {\n                    return new ResultBuckets(item);\n                });\n            }\n            if (input.facets) {\n                this.facets = input.facets.map((item: any) => {\n                    return new GenericFacetResponse(item);\n                });\n            }\n            if (input.spellcheck) {\n                this.spellcheck = input.spellcheck.map((item: any) => {\n                    return new ResultSetContextSpellcheck(item);\n                });\n            }\n        }\n    }\n\n}\n"]}