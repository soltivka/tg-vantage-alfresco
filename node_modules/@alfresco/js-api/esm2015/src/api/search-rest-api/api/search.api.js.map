{"version":3,"file":"search.api.js","sourceRoot":"","sources":["search.api.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;EAeE;AAEF,OAAO,EAAE,eAAe,EAAE,MAAM,0BAA0B,CAAC;AAE3D,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AACrC,OAAO,EAAE,iBAAiB,EAAE,MAAM,iBAAiB,CAAC;AAMpD,MAAM,OAAO,SAAU,SAAQ,OAAO;IAgTlC,MAAM,CAAC,SAAwB;QAC3B,iBAAiB,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;QAE1C,IAAI,QAAQ,GAAG,SAAS,CAAC;QAEzB,IAAI,UAAU,GAAG,EAEhB,CAAC;QAEF,IAAI,WAAW,GAAG,EACjB,CAAC;QAEF,IAAI,YAAY,GAAG,EAElB,CAAC;QACF,IAAI,UAAU,GAAG,EAChB,CAAC;QAEF,IAAI,YAAY,GAAG,CAAC,kBAAkB,CAAC,CAAC;QACxC,IAAI,OAAO,GAAG,CAAC,kBAAkB,CAAC,CAAC;QAEnC,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CACzB,SAAS,EAAE,MAAM,EACjB,UAAU,EAAE,WAAW,EAAE,YAAY,EAAE,UAAU,EAAE,QAAQ,EAC3D,YAAY,EAAE,OAAO,EAAE,eAAe,CAAC,CAAC;IAChD,CAAC;CAEJ","sourcesContent":["/*!\n* @license\n* Copyright 2018 Alfresco Software, Ltd.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { ResultSetPaging } from '../model/resultSetPaging';\nimport { SearchRequest } from '../model/searchRequest';\nimport { BaseApi } from './base.api';\nimport { throwIfNotDefined } from '../../../assert';\n\n/**\n* Search service.\n* @module SearchApi\n*/\nexport class SearchApi extends BaseApi {\n    /**\n    * Searches Alfresco\n    *\n    * **Note**: this endpoint is available in Alfresco 5.2 and newer versions.\n\n**You specify all the parameters in this API in a JSON body**, URL parameters are not supported.\nA basic query looks like this:\n\nJSON\n{\n  \\\"query\\\": {\n    \\\"query\\\": \\\"foo\\\"\n  }\n}\n\n**Note:** These are the minimum possible query parameters.\n\nThe default search language is **afts** ([Alfresco Full Text Search](http://docs.alfresco.com/5.1/concepts/rm-searchsyntax-intro.html)), but you can also specify **cmis**, and **lucene**.\n\nA basic CMIS query looks like this:\n\nJSON\n{\n  \\\"query\\\": {\n    \\\"query\\\": \\\"select * from cmis:folder\\\",\n    \\\"language\\\": \\\"cmis\\\"\n  }\n}\n\nBy default, **results are limited to the first 100.**\nResults can be restricted using \\\"paging\\\". For example:\nJSON\n\\\"paging\\\": {\n  \\\"maxItems\\\": \\\"50\\\",\n  \\\"skipCount\\\": \\\"28\\\"\n}\n\nThis example would ensure that results are **limited by Final Size**,\nskipping the first 28 results and returning the next 50.\n\nAlternatively, you can limit the results by using the **limits JSON body parameter**. For example,\nJSON\n\\\"limits\\\": {\n  \\\"permissionEvaluationTime\\\": 20000,\n  \\\"permissionEvaluationCount\\\": 2000\n}\n\nYou can use the **include JSON body parameter** to return additional information.\nThis works in the same way as in the /nodes/{nodeId}/children method in the core API. For example:\nJSON\n\\\"include\\\": [\\\"aspectNames\\\", \\\"properties\\\", \\\"isLink\\\"]\n\nYou can use the **fields JSON body parameter** to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.\nThis works in the same way as in the /nodes/{nodeId}/children method in the core API. For example:\nJSON\n\\\"fields\\\": [\\\"id\\\", \\\"name\\\", \\\"search\\\"]\n\nYou can sort the results using the **sort JSON body parameter**, for example:\nJSON\n\\\"sort\\\": [{\\\"type\\\":\\\"FIELD\\\", \\\"field\\\":\\\"cm:description\\\", \\\"ascending\\\":\\\"true\\\"}]\n\n**Note:** the **sort** parameter is not supported for CMIS queries.\n\nBy default, search uses the **\\\"nodes\\\" location**, which is the **content store known as workspace://SpacesStore**.\nTo change the scope to another location you can use the **locations JSON body parameter**. You can specify either **nodes** (the default), **versions** or **deleted-nodes**.  For example,\nJSON\n\\\"scope\\\": {\n    \\\"locations\\\": [\\\"deleted-nodes\\\"]\n}\n\nYou can specify templates using the **templates JSON body parameter**, for example:\nJSON\n\\\"templates\\\": [{\\\"name\\\": \\\"_PERSON\\\",\\\"template\\\": \\\"|%firstName OR |%lastName OR |%userName\\\"},\n              {\\\"name\\\": \\\"mytemplate\\\",\\\"template\\\": \\\"%cm:content\\\"}]\n\n**Note: Spell checking only works on Search Services (Solr 6) if you have already enabled suggestions.**\n\nFor **spell checking** you can use a query like this:\nJSON\n{\n  \\\"query\\\": {\n    \\\"query\\\": \\\"cm:title:alfrezco\\\"\n  },\n  \\\"spellcheck\\\": {\\\"query\\\": \\\"alfrezco\\\"}\n}\n\nIf you are already specifying \\\"userQuery\\\" then the following may be easier\nand produces the same result :\nJSON\n{\n  \\\"query\\\": {\n    \\\"query\\\": \\\"cm:title:alfrezco\\\",\n    \\\"userQuery\\\": \\\"alfrezco\\\"\n  },\n  \\\"spellcheck\\\": {}\n}\n\nThe spellcheck response includes a spellCheck context like this:\nJSON\n\\\"context\\\": {\n  \\\"spellCheck\\\": {\n    \\\"type\\\": \\\"searchInsteadFor\\\",\n    \\\"suggestions\\\": [\\\"alfresco\\\"]\n  }\n},\n\nTo specify defaults, you  use a **defaults JSON body parameter**, for example:\nJSON\n\\\"defaults\\\": {\n  \\\"textAttributes\\\": [\n    \\\"cm:content\\\", \\\"cm:name\\\"\n  ],\n  \\\"defaultFTSOperator\\\": \\\"AND\\\",\n  \\\"defaultFTSFieldOperator\\\": \\\"OR\\\",\n  \\\"namespace\\\": \\\"cm\\\",\n  \\\"defaultFieldName\\\": \\\"PATH\\\"\n}\n\nYou can specify several filter queries using the **filterQueries JSON body parameter**, for example:\nJSON\n\\\"filterQueries\\\": [{\\\"query\\\": \\\"TYPE:'cm:folder'\\\"},{\\\"query\\\": \\\"cm:creator:mjackson\\\"}]\n\nYou can specify several facet queries using the **facetQueries JSON body parameter**, for example:\nJSON\n\\\"facetQueries\\\": [{\\\"query\\\": \\\"created:2016\\\",\\\"label\\\": \\\"CreatedThisYear\\\"}]\n\nThe response will contain a matching \\\"context\\\" section, the \\\"label\\\" will match the facet query.\nJSON\n\\\"context\\\": {\n  \\\"facetQueries\\\": [\n    {\\\"label\\\": \\\"CreatedThisYear\\\",\\\"count\\\": 3}\n  ]\n},\n\nA complete query for facetting via the content.size field looks this:\nJSON\n{\n  \\\"query\\\": {\n    \\\"query\\\": \\\"presentation\\\",\n    \\\"language\\\": \\\"afts\\\"\n  },\n    \\\"facetQueries\\\": [\n        {\\\"query\\\": \\\"content.size:[0 TO 10240]\\\", \\\"label\\\": \\\"xtra small\\\"},\n        {\\\"query\\\": \\\"content.size:[10240 TO 102400]\\\", \\\"label\\\": \\\"small\\\"},\n        {\\\"query\\\": \\\"content.size:[102400 TO 1048576]\\\", \\\"label\\\": \\\"medium\\\"},\n        {\\\"query\\\": \\\"content.size:[1048576 TO 16777216]\\\", \\\"label\\\": \\\"large\\\"},\n        {\\\"query\\\": \\\"content.size:[16777216 TO 134217728]\\\", \\\"label\\\": \\\"xtra large\\\"},\n        {\\\"query\\\": \\\"content.size:[134217728 TO MAX]\\\", \\\"label\\\": \\\"XX large\\\"}\n  ],\n    \\\"facetFields\\\": {\\\"facets\\\": [{\\\"field\\\": \\\"'content.size'\\\"}]}\n}\n\nThe response will contain a matching \\\"context\\\" section, the \\\"label\\\" will match the facet query.\nJSON\n\\\"context\\\": {\n  \\\"facetQueries\\\": [\n    { \\\"label\\\": \\\"small\\\",\\\"count\\\": 2 },\n    { \\\"label\\\": \\\"large\\\",\\\"count\\\": 0 },\n    { \\\"label\\\": \\\"xtra small\\\",\\\"count\\\": 5 },\n    { \\\"label\\\": \\\"xtra large\\\",\\\"count\\\": 56},\n    { \\\"label\\\": \\\"medium\\\",\\\"count\\\": 4 },\n    { \\\"label\\\": \\\"XX large\\\", \\\"count\\\": 1 }\n  ]\n},\n\nYou can specify several facet fields using the **facetFields JSON body parameter**, for example:\nJSON\n\\\"facetFields\\\": {\\\"facets\\\": [{\\\"field\\\": \\\"creator\\\", \\\"mincount\\\": 1}, {\\\"field\\\": \\\"modifier\\\", \\\"mincount\\\": 1}]}\n\nThe response will contain a matching \\\"context\\\" section, the \\\"label\\\" will match the facet field.\nJSON\n\\\"context\\\": {\n   \\\"facetsFields\\\": [\n     {  \\\"label\\\": \\\"creator\\\",\n        \\\"buckets\\\": [\n          { \\\"label\\\": \\\"System\\\", \\\"count\\\": 75 },\n          { \\\"label\\\": \\\"mjackson\\\", \\\"count\\\": 5 }\n        ]},\n     {  \\\"label\\\": \\\"modifier\\\",\n        \\\"buckets\\\": [\n          { \\\"label\\\": \\\"System\\\", \\\"count\\\": 72 },\n          { \\\"label\\\": \\\"mjackson\\\", \\\"count\\\": 5 },\n          { \\\"label\\\": \\\"admin\\\", \\\"count\\\": 3 }\n        ]}\n   ]\n},\n\nGrouping facet queries that go together can be done by specifying the group label in the fact queries as follow:\nJSON\n    {\n        \\\"query\\\": {\n            \\\"query\\\": \\\"presentation\\\"\n        },\n        \\\"facetQueries\\\": [\n            {\\\"query\\\": \\\"content.size:[0 TO 102400]\\\", \\\"label\\\": \\\"small\\\", \\\"group\\\":\\\"foo\\\"},\n            {\\\"query\\\": \\\"content.size:[102400 TO 1048576]\\\", \\\"label\\\": \\\"medium\\\",\\\"group\\\":\\\"foo\\\"},\n            {\\\"query\\\": \\\"content.size:[1048576 TO 16777216]\\\", \\\"label\\\": \\\"large\\\",\\\"group\\\":\\\"foo\\\"}\n        ]\n    }\n\nThe above query returns the results a faceted field grouped under the label foo:\nJSON\n{\n    \\\"context\\\": {\\\"facetsFields\\\": [{\n        \\\"label\\\": \\\"foo\\\",\n        \\\"buckets\\\": [\n            {\n                \\\"count\\\": 109,\n                \\\"label\\\": \\\"small\\\",\n                \\\"filterQuery\\\": \\\"content.size:[0 TO 102400]\\\"\n            },\n            {\n                \\\"count\\\": 0,\n                \\\"label\\\": \\\"large\\\",\n                \\\"filterQuery\\\": \\\"content.size:[1048576 TO 16777216]\\\"\n            },\n            {\n                \\\"count\\\": 0,\n                \\\"label\\\": \\\"medium\\\",\n                \\\"filterQuery\\\": \\\"content.size:[102400 TO 1048576]\\\"\n            }\n        ]\n    }]\n}\n\nRange Faceting is supported by the **ranges JSON body parameter**, for example:\nJSON\n    {\n        \\\"query\\\": {\n            \\\"query\\\": \\\"presentation\\\"\n        },\n        \\\"ranges\\\": [\n        {\n            \\\"field\\\": \\\"content.size\\\",\n             \\\"start\\\": \\\"0\\\",\n             \\\"end\\\": \\\"100\\\",\n             \\\"gap\\\": \\\"20\\\",\n             \\\"hardend\\\": true\n        },\n        {\n            \\\"field\\\": \\\"created\\\",\n            \\\"start\\\": \\\"2015-09-29T10:45:15.729Z\\\",\n            \\\"end\\\": \\\"2016-09-29T10:45:15.729Z\\\",\n            \\\"gap\\\": \\\"+100DAY\\\"\n        }]\n    }\n\nAn example query for **search highlighting** could look like this:\nJSON\n{\n  \\\"query\\\": {\n    \\\"query\\\": \\\"description:workflow\\\",\n    \\\"userQuery\\\":\\\"workflow\\\"\n  },\n  \\\"highlight\\\": {\n    \\\"prefix\\\": \\\"¿\\\",\n    \\\"postfix\\\": \\\"?\\\",\n    \\\"mergeContiguous\\\": true,\n    \\\"fields\\\": [\n      {\n        \\\"field\\\": \\\"cm:title\\\"\n      },\n      {\n        \\\"field\\\": \\\"description\\\",\n        \\\"prefix\\\": \\\"(\\\",\n        \\\"postfix\\\": \\\")\\\"\n      }\n\n    ]\n  }\n}\n\nThe example above changes the highlighting prefix and postfix from the\n default <em> for all fields to ¿? and just for the \\\"description\\\" field to ().\n The highlight information is added in each node entry response; here is\n an example partial response:\n\n\\\"entry\\\": {\n        \\\"createdAt\\\": \\\"2016-10-12T15:24:31.202+0000\\\",\n        \\\"isFolder\\\": true,\n        \\\"search\\\": {\n          \\\"score\\\": 1,\n          \\\"highlight\\\": [\n            {\n              \\\"field\\\": \\\"cm:title\\\",\n              \\\"snippets\\\": [\n                \\\"Customized ¿Workflow? Process Definitions\\\"\n              ]\n            },\n            {\n              \\\"field\\\": \\\"description\\\",\n              \\\"snippets\\\": [\n                \\\"Customized (Workflow) Process Definitions\\\"\n              ]\n            }\n          ]\n      },\n\n    *\n    * @param queryBody Generic query API\n\n    * @return Promise<ResultSetPaging>\n    */\n    search(queryBody: SearchRequest): Promise<ResultSetPaging> {\n        throwIfNotDefined(queryBody, 'queryBody');\n\n        let postBody = queryBody;\n\n        let pathParams = {\n\n        };\n\n        let queryParams = {\n        };\n\n        let headerParams = {\n\n        };\n        let formParams = {\n        };\n\n        let contentTypes = ['application/json'];\n        let accepts = ['application/json'];\n\n        return this.apiClient.callApi(\n            '/search', 'POST',\n            pathParams, queryParams, headerParams, formParams, postBody,\n            contentTypes, accepts, ResultSetPaging);\n    }\n\n}\n"]}